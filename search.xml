<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[约束]]></title>
    <url>%2F2019%2F10%2F17%2F%E7%BA%A6%E6%9D%9F%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[今日内容 DQL查询语句 排序查询 聚合查询 分组查询 分页查询 约束 多表之间的关系 范式 数据库的备份和还原#DQL: 查询语句 排序查询 语法： order by 子句 order by排序字段1.排序方式1，排序字段2.排序方式2… 排序方式： ASC升序 默认的 DESC降序 注意如果有多个排序条件，则前边的条件值一样时，才会去判断第二条件。 聚合查询 ：将一列数据作为一个整体，进行纵向的计算， count： 计算个数 一般选择非空的列： “主键” count(*) max：计算最大值 min:计算最小值 sum：计算和 avg：计算平均值 注意聚合函数的计算他会排除null值 解决方案 第一选择不包含非空的列进行计算 ifbull 分组查询: 语法：group by 分组列 having 过滤条件 注意： 分组之后查询的字段：分组字段。聚合函数。 where和having的区别? where在分组之前进行鉴定,如果不满足条件,则不参与分组.having在分组之后进行限定,如果不满足条件,则不会被查询出来 where后不可以跟聚合函数,having可以进行稽核函数的判断 分页查询: 语法：limit开始的索引，每页查询的条数 公式：公式： 开始的索引 （当前的页面 - 1）* 每页显示的条件 1234select * from stu limit 0,3; -- 第一页select * from stu limit 3,3; -- 第二页-- 公式： 开始的索引 （当前的页面 - 1）* 每页显示的条件select * from stu limit 6,3; -- 第三页 limit操作是一个mysql方言 约束 概念: 对表中的数据进行限定,保证数据的正确性,有效性和完整性. 分类: 主键约束: primary key 非空约束: not null 唯一约束: unique 外键约束: foreign key 非空约束: not null 在创建表时来添加约束: 1234create table db1.stu1( id int, name varchar(20) not null -- name非空) * 创建表完事之后添加非空约束: 1alter table stu1 MODIFY name varchar(20) not null; * 删除非空约束: 1alter table stu1 MODIFY name VARCHAR(20); * 唯一约束: `unique`值不能重复 * 创建表时添加唯一约束 1234create table stu1( id int, phone_number VARCHAR(20) unique -- 添加唯一约束); * 注意mysql中唯一约束限定的列的值可以有多个null * 删除唯一约束 1alter table stu1 drop index phone_number; * 创建表之后添加唯一约束 1alter table stu1 modify phone_number varchar(20) unique; * 主键约束: `primary key` * 在创建表时,添加主键约束 12345678910create table stu2( id INT primary key, -- 给id添加主键 name varchar(20));-- 删除主键-- 错误 alter table stu2 modify id int; alter table stu2 drop PRIMARY KEY;-- 创建完表之后添加主键alter table stu2 MODIFY id int PRIMARY KEY;select * from stu2; * 自动增长: * 如果某一列是数类型的,使用 `auto_increment` 可以来完成值自动增长 1234567891011create table stu3( id INT primary key AUTO_INCREMENT, -- 给id添加主键 name varchar(20));insert into stu3 (id,`name`)values(1,&apos;aaa&apos;);insert into stu3 (id,`name`)values(null,&apos;bbb&apos;);-- 注意:自动增长的值跟着上一个值动-- 删除自动增长alter table stu3 MODIFY id int;-- 添加自动增长alter table stu3 modify id int AUTO_INCREMENT; * 注意: * 含义: 非空且唯一 * 一张表只能有一个字段为主键 -- &gt; 一张表中记录的唯一标识 * 外键约束: `foreign key`让表与表产生关系,保证数据的正确性. * 在创建表时来添加外键 * 语法: 12345create table 表名( ... 外键列 constraint 外键名称 foreign key (外键列名称) reference 主表名称(列的名称)); * 删除外键 * 1alter table 表的名称 drop FOREIGN key 外键名称; * 创建表之后添加外键 1alter table 表的名称 add constraint 外键名称 foreign key (外键列名称) reference 主表名称(列的名称) * 级联操作 * 添加级联的操作 * 语法: 1alter table 表的名称 add constraint 外键名称 foreign key (外键列名称) reference 主表名称(列的名称) ON UPDATE CASCADE ON DELETE CASCADE; * 分类: * 级联更新:`ON UPDATE CASCADE` * 级联删除:`ON DELETE CASCADE`数据库的设计 多表之间的关系 一对一: 如: 人和身份证 分析:一个人只有一个身份证,一个身份证只能对应一个人 实现方式:可以在任意一方添加唯一unique外键指向另一方的主键 一对多(多对一): 如部门和员工 实现方式:在多的一方建立外键,指向一的一方的主键 多对多 如学生和课程 实现方式:多对多的关系必须借助第三张中间表,中间表至少包含两个字段,这两个字段作为第三章表的外键,分别指向两张表的主键 小案例* 数据库设计的范式 概念:–&gt;百度百科 分类 第一范式(1NF):即数据库表的每一列都是不可分割的原子数据项 第二范式(2NF):在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖） 几个概念 函数依赖:A—&gt;B,如果通过A属性(属性组)的值,可以确定唯一的属性的值,则称B依赖于A 如学号被姓名所依赖 完全函数依赖:A—&gt;B,若果A是一个属性组,则B属性值的确定需要依赖属性组的所有属性值 (学号,课程名称)—&gt;分数 部分完全依赖:A—&gt;B,若果A是一个属性组.则B属性值的确定只需要依赖于A属性组中的某一些值即可 例如(学号,课程名称) —-&gt; 姓名 传递函数依赖:A–&gt;B,B–&gt;C,如果通过A 属性(属性组)的值,可以确定唯一,在通过B 属性组的值确定C时唯一C属性的值,则称C被传递依赖 学号–&gt;系名,系名–&gt;系主任 码:如果一个属性或属性组,被其他所有属性所完全依赖,则称这个属性组为该表的码 例如:(学号,课程名称) 主属性:码属性组中的所有属性 非主属性:除过码属性组的属性 第三范式(3NF):在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖） 数据库的备份和还原 命令行: 语法: 备份:mysqldump -u用户名 -p密码 数据库的名称&gt; 保存的路径 还原: 登录数据库 创建数据库 使用数据库 执行文件source文件路径]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库的设计</tag>
        <tag>数据库的备份和还原</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多表查询]]></title>
    <url>%2F2019%2F10%2F17%2F%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[今日内容 多表查询 事务 DCL 多表查询 查询语法 123456select 列名列表from 表名列表where... * 笛卡尔积: 有两个集合A,B,取这两个集合的所有组成情况 要完成多表查询,需要消除无用的数据 多表查询分类 内连接查询: 隐式内敛及:使用where条件消除无用的信息 123456789SELECT t1.NAME, -- 员工表的姓名 t1.gender, -- 员工表的性别 t2.NAME -- 部门表姓名from emp t1, dept t2where t1.dept_id = t2.id; * 显示内连接: * 语法:`select`字段列表 `from` 表名1 `inner` `join` 表名2 1SELECT * FROM emp [INNER] JOIN dept ON emp.dept_id = dept.id; * 内连接查询: * 从哪些表中查数据 * 查询条件是什么 * 查询哪些字段 外连接查询: 左外连接: 语法:select 字段列表 from 表1 left [outer] join 表2 on 条件; 查询的是左表所有数据以及其交集部分 右外连接 语法:select 字段列表 from 表1 right [outer] join 表2 on 条件; 子查询: 概念:查询中嵌套查询,成为子查询. 1234567-- 例子-- 查询最高的工资SELECT MAX(salary) FROM emp;-- 查询员工信息并且工资等于9000的select * FROM emp where emp.salary = 9000;-- 一条sql语句完成这个操作select * FROM emp where emp.salary = (SELECT MAX(salary) FROM emp); 子查询的不同情况 子查询的结果是单行单列的: 子查询可以作为条件,使用运算符去判断,运算符: &gt; &lt; &gt;= &lt;= = 12-- 例子查询工资小于平均工资的人select * from emp where emp.salary &lt; (select avg(salary) from emp); 子查询的结果是多行单列的: 子查询可以作为条件的可以采用in作为条件 123456-- 查询财务部和市场部所有的员工信息select id from dept WHERE NAME = &apos;财务部&apos; or NAME =&apos;市场部&apos;;select * from emp where dept_id = 3 or dept_id = 2;select * from emp where dept_id in (3,2);-- 子查询select * from emp where dept_id in (select id from dept WHERE NAME = &apos;财务部&apos; or NAME =&apos;市场部&apos;); 子查询的结果是多行多列的: 子查询可以作为一张虚拟表 1234-- 子查询-- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息select * from dept t1,(select * from emp where emp.join_date &gt; &apos;2011-11-11&apos;) t2where t1.id = t2.dept_id; 普通内连接 1select * from emp t1,dept t2 where t1.dept_id = t2.id and t1.dept_date &gt; &apos;2011-11-11&apos;; 多表查询练习 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178-- 部门表CREATE TABLE dept ( id INT PRIMARY KEY PRIMARY KEY, -- 部门id dname VARCHAR(50), -- 部门名称 loc VARCHAR(50) -- 部门所在地);-- 添加4个部门INSERT INTO dept(id,dname,loc) VALUES (10,&apos;教研部&apos;,&apos;北京&apos;),(20,&apos;学工部&apos;,&apos;上海&apos;),(30,&apos;销售部&apos;,&apos;广州&apos;),(40,&apos;财务部&apos;,&apos;深圳&apos;);-- 职务表，职务名称，职务描述CREATE TABLE job ( id INT PRIMARY KEY, jname VARCHAR(20), description VARCHAR(50));-- 添加4个职务INSERT INTO job (id, jname, description) VALUES(1, &apos;董事长&apos;, &apos;管理整个公司，接单&apos;),(2, &apos;经理&apos;, &apos;管理部门员工&apos;),(3, &apos;销售员&apos;, &apos;向客人推销产品&apos;),(4, &apos;文员&apos;, &apos;使用办公软件&apos;);-- 员工表CREATE TABLE emp ( id INT PRIMARY KEY, -- 员工id ename VARCHAR(50), -- 员工姓名 job_id INT, -- 职务id mgr INT , -- 上级领导 joindate DATE, -- 入职日期 salary DECIMAL(7,2), -- 工资 bonus DECIMAL(7,2), -- 奖金 dept_id INT, -- 所在部门编号 CONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job (id), CONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept (id));-- 添加员工INSERT INTO emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) VALUES (1001,&apos;孙悟空&apos;,4,1004,&apos;2000-12-17&apos;,&apos;8000.00&apos;,NULL,20), (1002,&apos;卢俊义&apos;,3,1006,&apos;2001-02-20&apos;,&apos;16000.00&apos;,&apos;3000.00&apos;,30),(1003,&apos;林冲&apos;,3,1006,&apos;2001-02-22&apos;,&apos;12500.00&apos;,&apos;5000.00&apos;,30),(1004,&apos;唐僧&apos;,2,1009,&apos;2001-04-02&apos;,&apos;29750.00&apos;,NULL,20),(1005,&apos;李逵&apos;,4,1006,&apos;2001-09-28&apos;,&apos;12500.00&apos;,&apos;14000.00&apos;,30),(1006,&apos;宋江&apos;,2,1009,&apos;2001-05-01&apos;,&apos;28500.00&apos;,NULL,30),(1007,&apos;刘备&apos;,2,1009,&apos;2001-09-01&apos;,&apos;24500.00&apos;,NULL,10),(1008,&apos;猪八戒&apos;,4,1004,&apos;2007-04-19&apos;,&apos;30000.00&apos;,NULL,20),(1009,&apos;罗贯中&apos;,1,NULL,&apos;2001-11-17&apos;,&apos;50000.00&apos;,NULL,10),(1010,&apos;吴用&apos;,3,1006,&apos;2001-09-08&apos;,&apos;15000.00&apos;,&apos;0.00&apos;,30),(1011,&apos;沙僧&apos;,4,1004,&apos;2007-05-23&apos;,&apos;11000.00&apos;,NULL,20),(1012,&apos;李逵&apos;,4,1006,&apos;2001-12-03&apos;,&apos;9500.00&apos;,NULL,30),(1013,&apos;小白龙&apos;,4,1004,&apos;2001-12-03&apos;,&apos;30000.00&apos;,NULL,20),(1014,&apos;关羽&apos;,4,1007,&apos;2002-01-23&apos;,&apos;13000.00&apos;,NULL,10);-- 工资等级表CREATE TABLE salarygrade ( grade INT PRIMARY KEY, -- 级别 losalary INT, -- 最低工资 hisalary INT -- 最高工资);-- 添加5个工资等级INSERT INTO salarygrade(grade,losalary,hisalary) VALUES (1,7000,12000),(2,12010,14000),(3,14010,20000),(4,20010,30000),(5,30010,99990);-- 需求：-- 1.查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述/* 分析: 1,查询员工编号，员工姓名，工资需要查询emp 职务名称，职务描述需要查询job 2,查询条件 emp.job_id = job.id*/SELECT t1.id, t1.ename, t1.salary, t2.jname, t2.descriptionFROM emp t1,job t2WHERE t1.job_id = t2.id;-- 2.查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置SELECT t1.id, t1.ename, t1.salary, t2.jname, t2.description, t3.dname, t3.locFROM emp t1,job t2,dept t3WHERE t1.job_id = t2.id and t1.dept_id = t3.id;-- 3.查询员工姓名，工资，工资等级SELECT t1.ename, t1.salary, t2.gradeFROM emp t1,salarygrade t2WHERE t1.salary BETWEEN t2.losalary AND t2.hisalary;-- 4.查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级SELECT t1.ename, t1.salary, t2.jname, t2.description, t3.dname, t3.loc, t4.gradeFROM emp t1,job t2,dept t3,salarygrade t4WHERE t1.job_id = t2.id and t1.dept_id = t3.id and t1.salary BETWEEN t4.losalary AND t4 .hisalary;-- 5.查询出部门编号、部门名称、部门位置、部门人数/* 分析: 1.部门编号、部门名称、部门位置dept表. 部门人数 emp表 2.使用分组查询,按照emp.dept_id完成分组查询count(id) 3.使用子查询将第二部的查询结果dept进行关联*/SELECT t1.id,t1.dname,t1.loc,t2.totalFROM dept t1, (SELECT dept_id,COUNT(id) total from emp GROUP BY dept_id) t2WHERE t1.id = t2.dept_id; -- 6.查询所有员工的姓名及其直接上级的姓名,没有领导的员工也需要查询/* 分析: 1.姓名 emp, 直接上级姓名 emp emp表的id和mgr自关联 2.条件 emp.id = emp.mgr 3.查询左表的所有数据和交集数据 (使用左外连接查询)*/SELECT t1.ename, t1.mgr, t2.id, t2.enamefrom emp t1LEFT JOIN emp t2on t1.mgr = t2.id; 事务 事务的基本介绍 概念 : 如果一个包含多个步骤的业务操作被事务管理,那么这些操作要么同事成功,要么同事失败. 操作 : 开始事务 : start transaction; 回滚 :rollback; 提交 :commit; 12345678910111213-- 开启事务START TRANSACTION;-- 张三账户减500UPDATE account SET balance = balance - 500 WHERE NAME = &apos;zhangsan&apos;;-- 李四账户加500UPDATE account SET balance = balance + 500 WHERE NAME = &apos;lisi&apos;;-- 发现没问题提交COMMIT;-- 发现出错误回滚事务ROLLBACK; MySQL数据库中事务默认自动提交 事务提交的两种方式: 自动提交 :mysql就是自动提交的 一条DML(增删改)语句会自动提交一次事务 手动提交 : oracle 数据库默认是手动提交事务的. 需要开启事务,在提交 修改事务的默认提交方式: 查看事务的默认提交方式 1SELECT @@autocommit; -- 1代表自动提交 0 代表手动提交 修改默认提交方式 1set @@autocommit = 0; 事务的四大特征 原子性 : 他是不可分割的最小操作单位,要么同时成功要么同时失败. 持久性 : 当事务提交和回滚后,数据库会发生持久化的保存数据 隔离性 : 多个事务之间.相互独立 一致性 ：事务操作前后，数据总量不变 事务的隔离级别(了解) 概念 ：多个事务之前隔离的，相互独立的。如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题了 存在问题： 脏读：一个事务，读取到另一个事务中没有提到的数据 不可重复读（虚读）：再同一个事务中两次读取到的数据不一样 幻读：一个事务操作（DML）数据表中所有记录，另一个事务添加一条数据，则第一个事务查询不到自己的修改。 隔离级别 read uncommitted读未提交 产生的问题：脏读：不可重复读（虚读）幻读： read committed读以提交（Oracle默认） 产生的问题：不可重复读（虚读）幻读： repeatable read可重复读（MySQL默认） 产生的问题：幻读 serializable串行话 可以解决所有的问题 注意：隔离级别从小到大，安全性越来越高，效率越来越低 数据库查询隔离级别: select @@tx_isolation; 数据库设置隔离级别: set global transaction isolation level级别字符串; 演示: 12345set global transaction isolation level read uncommitted;start transaction;-- 转账操作update account set balance = balance - 100 where id = 1;update account set balance = balance + 100 where id = 2; DCL SQL分类: DDL:操作数据库和表 DML:增删改表中的数据 DQL查询表中的数据 DCL:管理用户,授权 DBA:数据库管理员 DCL:管理用户,授权 管理用户 用户的添加 删除用户 修改用户密码 12345UPDATE USER SET PASSWORD = PASSWORD(&apos;新密码&apos;) WHERE USER = &apos;用户名&apos;;UPDATE USER SET PASSWORD = PASSWORD(&apos;abc&apos;) WHERE USER = &apos;xiaohua&apos;;set PASSWORD FOR &apos;用户名&apos;@&apos;主机名&apos; = PASSWORD(&apos;新密码&apos;);set PASSWORD FOR &apos;小志&apos;@&apos;localhost&apos; = PASSWORD(&apos;abc&apos;); 在mysql中忘记root密码? cmd -- &gt; net stop mysql停止mysql服务(需要管理员) 启动mysql服务: mysqld --skip-grant-tables 打开新的cmd窗口直接输入mysql命令回车就可以登录成功 use mysql; update user set password = password(‘你的新密码’)where user = &#39;root&#39;; 关闭窗口打开任务管理器手动结束mysqld.exe的进程 启动mysql服务 使用新密码登录 查询用户 1234567891011-- % 通配符 可以在所有主机使用use mysql;SELECT * FROM `user`;CREATE USER &apos;用户名&apos;@&apos;主机名&apos; IDENTIFIED by &apos;密码&apos;;CREATE USER &apos;小志&apos;@&apos;localhost&apos; IDENTIFIED by &apos;123&apos;;CREATE USER &apos;小花&apos;@&apos;%&apos; IDENTIFIED by &apos;123&apos;;-- 删除用户DROP USER &apos;用户名&apos;@&apos;主机名&apos;;DROP USER &apos;小花&apos;@&apos;%&apos;; 权限管理: 查询权限: 1234-- 查询权限SHOW GRANTS FOR &apos;用户名&apos;@&apos;主机名&apos;;SHOW GRANTS FOR &apos;小志&apos;@&apos;localhost&apos;;SHOW GRANTS FOR &apos;root&apos;@&apos;%&apos;; * 授予权限: 123456-- 授予权限GRANT 权限列表 ON 数据库名.表名 TO &apos;用户名&apos;@&apos;主机名&apos;;GRANT select,DELETE,UPDATE ON db3.account TO &apos;小志&apos;@&apos;localhost&apos;;-- 给小花用户授予所有权限GRANT ALL ON *.* TO &apos;xiaohua&apos;@&apos;%&apos;; * 撤销权限: 12-- 撤销权限:REVOKE 权限列表 on 数据库名称.表名 from &apos;用户名&apos;@&apos;主机名&apos;;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>多表查询,事务,DCL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC]]></title>
    <url>%2F2019%2F10%2F17%2FJDBC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[内容 JDBC基本概念 快速入门 对JDBC中各个接口和类详解 JDBC: 概念:Java DataBase Connectivity``java数据库连接,java语言操作数据库 JDBC:其实是官方(sun)公司 定义的一套操作所有关系型数据库的规则,即接口,各个数据库厂商去实现这套接口,提供数据库驱动jar包,我们可以使用这套接口(JDBC)编程,真正执行的代码是驱动jar包中的实现类 快速入门: 步骤: 导入驱动jar包mysql-connector-java-8.0.18.jar 复制mysql-connector-java-8.0.18.jar包到目录libs下 右键–&gt;Add as Library添加 注册驱动 获取数据库的连接对象connection 定义sql语句 获取执行sql语句的对象statement 执行sql,接受返回结果 处理结果 释放资源 1234567891011121314151617181920212223242526272829/** JDBC快速入门* */import java.sql.Connection;import java.sql.DriverManager;import java.sql.Statement;public class JdbcDemo01 &#123; public static void main(String[] args) throws Exception &#123; //1.导入jar驱动 //2.注册驱动 Class.forName("com.mysql.jdbc.Driver"); //3.获取数据库连接对象 Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/db3", "root", "root"); //4.定义sql语句 String sql = "update account set balance = 500 where id = 1"; //5.获取执行sql的对象 Statement Statement stmt = conn.createStatement(); //6.执行sql int count = stmt.executeUpdate(sql); //7.处理结果 System.out.println(count); //8.释放资源 stmt.close(); conn.close(); &#125;&#125; 详解各个对象 DriverManager : 驱动管理对象 功能: 注册驱动: 告诉我们的程序该使用哪一个jar包 static void registerDriver(Driver driver):注册与给定的驱动程序 DriverManager写代码使用:Class.forName(&quot;com.mysql.jdbc.Driver&quot;);通过查看源码,发现在com.mysql.jdbc.Driver类中存在静态代码块 1234static &#123; System.err.println("Loading class `com.mysql.jdbc.Driver'. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver'. " + "The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary."); &#125; 注意:mysql5之后的驱动jjar包可以省略注册驱动的步骤. 获取数据库连接 方法: static Connection getConnection(String url,String user, String password) 参数: url:指定连接的路径 语法:jdbc:mysql://ip地址(域名):端口号/数据库名称 例子:jdbc:mysql://localhost:3306/db3 细节:如果连接的是本机的mysql服务器,并且mysql默认端口是3306,则url可以简写:jdbc:mysql://数据库名称 user:用户名 password:密码 Connection : 数据库连接对象 功能:获取执行sql对象 Statement createStatement() PreparedStatement preparStatement(String sql) 管理事务: 开启事务:void setAutoCommit(boolean autoCommit)调用该方法设置参数为false即开启事务 提交事务:commit 回滚事务:rollback Statement : 执行sql对象 执行sql boolean execute(String sql)可以执行任意的sql(了解) int executeUpdate(String sql):执行DML(insert update delete)语句.DDL(creat,alter,drop)语句 返回值:影响返回行数,可以通过影响的行数判断DML语句是否执行成功,返回值&gt;0执行成功反之失败 ResultSet executeQuery(String sql): 执行DQL语句(select)语句 练习: account表添加一条记录 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package cn.itcast.jdbc;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;/** account表 添加移交记录insert 语句* */public class JDBCDemo2 &#123; public static void main(String[] args) &#123; Statement stmt = null; Connection conn = null; //1 try &#123; Class.forName("com.mysql.cj.jdbc.Driver"); //2 String sql = "insert into account values(null,'王五',3000)"; //3 conn = DriverManager.getConnection("jdbc:mysql:///db3", "root", "root"); //4 stmt = conn.createStatement(); //5 int count = stmt.executeUpdate(sql);//count影响的行数 //6 System.out.println(count); if (count&gt;0)&#123; System.out.println("添加成功"); &#125;else &#123; System.out.println("添加失败"); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; //stmt.close(); //避免控制正异常 if (stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;if (conn != null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 2. `account`表删除一条记录 3. `account`表修改一条记录 Resultset : 结果处理对象,封装查询结果 boolean next光标从当前位置向下移动一行,判断当前行是否有数据,判断当前行是否为走一行末尾(是否有数据)如果是则返回false如果否返回true getxxx(参数):获取数据 xxx代表数据类型 如:getInt() getString() 参数: Int:代表列的编号.从1开始 如getString(1) String:代表列的名称. 如getDouble(&quot;balance&quot;) 注意 : 使用时 使用步骤: 游标向下移动一行 判断是否有数据 获取数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package cn.itcast.jdbc; import java.sql.*;public class JDBCDemo7 &#123; public static void main(String[] args) &#123; Connection conn = null; Statement stmt = null; ResultSet rs = null; try &#123; Class.forName("com.mysql.cj.jdbc.Driver"); conn = DriverManager.getConnection("jdbc:mysql:///db3", "root", "root"); String sql = "select * from account"; stmt = conn.createStatement(); rs = stmt.executeQuery(sql); //6处理结果 //6.1 让游标向下一动一行 //判断是否有数据 /*if(rs.next()) &#123; int id = rs.getInt(1); String name = rs.getString("name"); double balance = rs.getDouble(3); System.out.println(id + "---" + name + "---" + balance); &#125;*/ //最好写法 while (rs.next())&#123; //循环判断游标是否为最后一行末尾 //获取数据 int id = rs.getInt(1); String name = rs.getString("name"); double balance = rs.getDouble(3); System.out.println(id + "---" + name + "---" + balance); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; if (stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;if (conn != null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;if (rs != null)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 练习: 定义一个方法,查询emp表的数据将其封装为对象,然后装在集合,返回 定义一个emp类 定义方法public List&lt;emp&gt; findAll(){} 事项方法select * from emp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package cn.itcast.domain;import java.sql.*;import java.util.ArrayList;import java.util.List;/**** 定义一个方法,查询`emp`表的数据将其封装为对象,然后装在集合,返回*/public class JDBCDemo8 &#123; public static void main(String[] args) &#123; List&lt;Emp&gt; list = new JDBCDemo8().findAll(); System.out.println(list); System.out.println(list.size()); &#125; /** * 查询所有emp对象 * @return */ Connection coon = null; Statement stmt = null; ResultSet rs = null; List&lt;Emp&gt; list = null; public List&lt;Emp&gt; findAll()&#123; try &#123; //1.注册驱动 Class.forName("com.mysql.cj.jdbc.Driver"); //2.获取连接 coon = DriverManager.getConnection("jdbc:mysql:///db3", "root", "root"); //3.定义sql String sql = "select * from emp"; //4.执行sql对象 stmt = coon.createStatement(); //5.执行sql rs = stmt.executeQuery(sql); //6.遍历结果集,封装对象,装在结合 Emp emp = null; list = new ArrayList&lt;Emp&gt;(); while (rs.next())&#123; //7.获取数据 int id = rs.getInt("id"); String ename = rs.getString("ename"); int job_id = rs.getInt("job_id"); int mgr = rs.getInt("mgr"); Date joindate = rs.getDate("joindate"); double salary = rs.getDouble("salary"); double bonus = rs.getDouble("bonus"); int dept_id = rs.getInt("dept_id"); //创建emp对象,并赋值 emp = new Emp(); emp.setId(id); emp.setEname(ename); emp.setJob_id(job_id); emp.setMgr(mgr); emp.setJoindate(joindate); emp.setSalary(salary); emp.setBonus(bonus); emp.setDept_id(dept_id); //装载集合 list.add(emp); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; if (rs != null)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (coon != null)&#123; try &#123; coon.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return list; &#125;&#125; PrepardStatement : 执行sql对象 sql注入问题 : 在拼接sql时,有一些sql的特殊关键字参与字符串的拼接,会造成安全性问题 解决sql注入问题 预编译sql : 参数使用?作为占位符 步骤 : 导入驱动jar包mysql-connector-java-8.0.18.jar 复制mysql-connector-java-8.0.18.jar包到目录libs下 右键–&gt;Add as Library添加 注册驱动 获取数据库的连接对象connection 定义sql语句 注意 : sql的参数使用?作为占位符.如 : select * from user = ? nad password ?; 获取执行sql语句的对象PrepardStatement``Connection.prepareStatement(String sql) 给?赋值 : 方法 : setxxx(参数1,参数2) 执行sql,接受返回结果,不需要传递sql语句了 10. 处理结果 释放资源 注意 : 后期都会使用PreparedStatement来完成增删改查的所有操作 可以防止sql注入 效率更高 抽取JDBC的工具类 : JDBCUtils 目的 : 简化书写 分析 : 注册驱动 抽取一个方法获取连接对象 需求 : 不想传递参数(麻烦),还得保证工具类的通用性 解决 : 配置文件 抽取一个方法要释放资源 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package cn.itcast.util;import java.io.FileReader;import java.io.IOException;import java.net.URL;import java.sql.*;import java.util.Properties;/** * JDBC工具类 */public class JDBCUtils &#123; /** * 只需要读取一次即可拿到这些值.使用静态代码块 */ private static String url; private static String user; private static String password; private static String driver; static &#123; try &#123; //读取资源文件,获取值 //1.创建Properties集合类 Properties pro = new Properties(); // 获取src路径下的文件方式 ---&gt; ClassLoader 类加载器 ClassLoader classLoader = JDBCUtils.class.getClassLoader(); URL resource = classLoader.getResource("jdbc.properties"); String path = resource.getPath(); System.out.println(path); //2.加载文件 //pro.load(new FileReader("src/jdbc.properties")); pro.load(new FileReader(path)); //3.获取数据,赋值 url = pro.getProperty("url"); user = pro.getProperty("user"); password = pro.getProperty("password"); driver = pro.getProperty("driver"); //4.注册驱动 Class.forName(driver); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取连接 * @return 连接对象 */ public static Connection getConnection() throws SQLException &#123; return DriverManager.getConnection(url,user,password); &#125; public static void close(Statement stmt,Connection conn)&#123; /** * 释放资源 */ if (stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void close(ResultSet rs, Statement stmt, Connection conn)&#123; /** * 释放资源 */ if (rs != null)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 练习 : 需求 : 通过键盘录入用户名和密码 判断用户是否登录成功 步骤 : 创建数据库表 USER 12345678910CREATE TABLE db4.USER( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(32), PASSWORD VARCHAR(32));SELECT * from USER;INSERT INTO USER VALUES(null,&apos;zhangsan&apos;,&apos;123&apos;);INSERT INTO USER VALUES(null,&apos;lisi&apos;,&apos;234&apos;); 创建一个类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package cn.itcast.jdbc;import cn.itcast.util.JDBCUtils;import java.sql.*;import java.util.Scanner;/** * 练习 : * * * 需求 : * * 通过键盘录入用户名和密码 * * 判断用户是否登录成功 */public class JDBCDemo9 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println("请输入用户名"); String username = sc.nextLine(); System.out.println("请输入密码"); String password = sc.nextLine(); boolean flag = new JDBCDemo9().login(username, password); if (flag)&#123; System.out.println("登录成功"); &#125;else &#123; System.out.println("用户名或者密码错误"); &#125; &#125; public boolean login(String username,String password)&#123; if (username == null || password == null)&#123; return false; &#125; Connection conn = null; Statement stmt = null; ResultSet rs = null; try &#123; conn = JDBCUtils.getConnection(); String sql = "select * from USER where username = '"+username+"' and password = '"+password+"'"; stmt = conn.createStatement(); rs = stmt.executeQuery(sql); /* if (rs.next())&#123; return true; &#125;else &#123; return false; &#125;*/ return rs.next();//如果有下一行则返回true &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCUtils.close(rs,stmt,conn); &#125; return false; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package cn.itcast.jdbc;import cn.itcast.util.JDBCUtils;import java.sql.*;import java.util.Scanner;/** * 练习 : * * * 需求 : * * 通过键盘录入用户名和密码 * * 判断用户是否登录成功 * * 使用PreparedStatement实现 */public class JDBCDemo10 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println("请输入用户名"); String username = sc.nextLine(); System.out.println("请输入密码"); String password = sc.nextLine(); boolean flag = new JDBCDemo10().login(username, password); if (flag)&#123; System.out.println("登录成功"); &#125;else &#123; System.out.println("用户名或者密码错误"); &#125; &#125; public boolean login(String username,String password)&#123; if (username == null || password == null)&#123; return false; &#125; Connection conn = null; PreparedStatement pstmt = null; ResultSet rs = null; try &#123; conn = JDBCUtils.getConnection(); String sql = "select * from USER where username = ? and password = ?"; pstmt = conn.prepareStatement(sql); //给?赋值 pstmt.setString(1,username); pstmt.setString(2,password); rs = pstmt.executeQuery(); /* if (rs.next())&#123; return true; &#125;else &#123; return false; &#125;*/ return rs.next();//如果有下一行则返回true &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCUtils.close(rs,pstmt,conn); &#125; return false; &#125;&#125; JDBC控制事务 : 事务 : 一个包含多个步骤的业务操作.如果这个业务操作事务管理,则这多个步骤要么同事成功,要么同时失败 操作 : 开启事务 提交事务 回滚事务 使用Connection对象来管理事务 开启事务 : setAutoCommit(boolean autoCommit): 调用改方法设置参数为false,即开启事务 在执行sql之前开启事务 提交事务 : commit() 当所有sql都执行完提交事务 回滚事务:rollback 在catch中回滚事务 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package cn.itcast.jdbc;import cn.itcast.util.JDBCUtils;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.SQLException;/** * 事务操作 */public class JDBCDemo11 &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement pstmt1 = null; PreparedStatement pstmt2 = null; try &#123; //获取连接 conn = JDBCUtils.getConnection(); //开启事务 conn.setAutoCommit(false); //定义sql //张三-500 String sql1 = "update account set balance = balance - ? where id = ?"; //李四+500 String sql2 = "update account set balance = balance + ? where id = ?"; //获取执行sql执行对象 pstmt1 = conn.prepareStatement(sql1); pstmt2 = conn.prepareStatement(sql2); //设置参数 pstmt1.setDouble(1,500); pstmt1.setInt(2,1); pstmt2.setDouble(1,500); pstmt2.setInt(2,2); //执行sql pstmt1.executeUpdate(); //手动制造异常 int i = 3/0; pstmt2.executeUpdate(); //提交事务 conn.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); //事务回滚 try &#123; if (conn != null) &#123; conn.rollback(); &#125; &#125; catch (SQLException ex) &#123; ex.printStackTrace(); &#125; &#125;finally &#123; //释放资源 JDBCUtils.close(pstmt1,conn); JDBCUtils.close(pstmt2,null); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
        <tag>JDBC工具类</tag>
        <tag>JDBC控制事务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库基础]]></title>
    <url>%2F2019%2F09%2F25%2FMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[今日内容数据库的基本概念 数据库的英文单词: DateBase 简称 : DB 什么是数据库? 用来储存和管理数据的仓库. 数据库的特点: 持久的存储数据.其实数据库就是一个文件系统 方便存储和管理数据 使用了统一的方式操作数据库 —SQL 常见的数据库软件–参考文档 MySQL数据库软件 安装 参见文档 卸载 去mysql的安装目录找到my.ini文件 复制datadir = ...去文件夹找 卸载MySQL 配置 MySQL服务启动 手动 cmd窗口建立一个命令,services.msc cmd使用管理员权限打开cmd net start mysql启动mysql服务 net stop mysql 关闭mysql服务 MySQL登录 mysql -uroot -proot mysql -hip地址 -uroot -p链接目标密码 mysql --host=IP地址--user=root --password=root MySQL退出 exit quit 配置文件my.ini MySQL数据目录 几个概念 数据库: 文件夹 表: 文件 数据: 数据 SQL 什么是SQL? Structured Query Language : 结构化查询语言 其实就是定义了操作所有关系型数据库的规则.每一种数据库操作的方式存在不一样的地方,成为”方言” SQL通用语法 SQL语句可以单行或多行书写,以分号结尾. 可以使用空格和缩进增进可读性 MySQL数据库的SQL语句不区分大小写,关键字建议大写 3种注释 单行注释: – 注释内容 或 # 注释内容(MySQL特有) 多行注释/* 注释*/ SQL分类 DDL:(操作数据库表) DML:(增删改表中的数据) DQL:(查询表中的数据) DCL:(授权–了解一下) DDL操作数据库.表 操作数据库: CRUD C(Create):创建 create database 数据库名称 create database if not exists判断数据库名称是否存在 create database 数据库名称 character set 字符集名 创建数据库判断是否有字符gbk create database if not exists db4 haracter set gbk; R(Retrieve):查询 :查看数据库的名称 show databases; :查看对应数据库的字符集 show create database mysql U(Update):修改 修改数据库的字符集 alter database数据库名称character set字符集名称 D(Delete):删除 drop database 数据库名称; drop database if exists 数据库名称 : 判断数据库是否存在在进行删除语法不会报错 使用数据库 查询当前正在使用的数据库名称 `select database(); 使用数据库 use 数据库名称 操作表 C(Create):创建 语法: create table表名(列名1 数据类型1, 列名2 数据类型2, ... 列名n 数据类型n ); 注意: 最后一列不需要加’逗号’(,) 数据类型: int类型 age int, double: 小数类型 score double(5.2) 小数类型 日期类型 date 只包含年月日, yyyy-MM-dd datetime 日期 包含年月日时分秒 yyyy-MM-dd HH:mm:ss timestamp时间错类型 包含年月日时分秒 yyyy-MM-dd HH:mm:ss 如果将来不给这个字段赋值,或赋值为null则默认系统默认时间,来自动赋值 varchar:字符串类型 name varchar(20):姓名最大20个字符 –&gt;zhangsan 8个字符–张三 两个字符 创建表 create table student( id int, name varchar(32), age int, score double(4,1), birthday date, insert_time timestamp); R(Retrieve):查询 查询某个数据库中所有的名称 show tables 查询表结构 desc表名; 复制表: create table 表名 like 需要复制的表 U(Update):修改 修改表名 alter table 表名 rename to 新的表名 修改表的字符集 alter table 表名 charactor set 字符集名称 添加 一列 alter table 表名 add 列名 数据类型; 修改列的名称和类型 alter table 表名 change gender 新列名 新数据类型; alter table表名 modify 新表明 数据类型; 删除列 alter table 表名 drop 列名; D(Delete):删除 drop table 表名; drop table if exists 表名 ; 客户端图形化的工具: SQLYOg; DML:增删改表中的数据(重点) 添加数据: 语法: insert into 表名(列名1,列名2,…列名n) values(值1,值2,…值n); 注意事项: 列名和值要一一对应; 如果表名后不定义列名,则默认给所有列添加值 除了数字类型,其他类型需要使用引号’’ 或 “” 引起来 删除数据: 语法: delete from 表名 [where 条件] 注意: 不加条件将删除表中的所有记录 delete from 表名; –不推荐 有多少条记录就汇之星多少次删除操作. truncate table表名 –推荐使用,先删除表,然后在创建一张一模一样的表. 修改数据: 语法: update表名set列名1 = 值1,列名2 = 值2,…[while 条件] 注意: 如果不加任何条件将会将表中所有记录全部修改 DQL: 查询表中的记录 select *from表名 语法: select 字段名列表 from表名列表 where条件列表 group分组字段 having分组之后的条件 order by排序 limit分页限定 基础查询 多个字段查询 select 字段名1，字段名2，…from 表明 注意: 如果使用所有字段可以使用* 替换所有字段列表 去除重复 distinct 计算列 一般可以使用四则用算来计算列的值（一般只会进行数值型计算） ifnull(表达式1，表达式2，)： 表达式1： 那个字段要判断是否为null 表达式2：如果该字段为null后的替换值 起别名 as名字 也可以空格加取得名字 条件查询 where 字句后跟条件 运算符： 、&lt;、&lt;=、&gt;=、=、&lt;&gt; BETWEEN...AND iN(集合) LIKE ‘张%’ —-&gt; 后期用的会多一下 占位符： _单个任意字符 %多个任意字符 – 查询班级里面姓马的？select * from stu where name like &#39;马%&#39;; – 查询第二个字是化的人 select * from stu where name like &#39;_化%&#39;; – 查询姓名是3个字的人 select * from stu where name like &#39;___&#39;; – 查询姓名中包含马的人 select * from stu where name like &#39;%马%&#39;; IS NULL and 或 &amp;&amp; or 或 || not 或 !]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>DDL</tag>
        <tag>DML</tag>
        <tag>DQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础加强]]></title>
    <url>%2F2019%2F09%2F25%2F%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Junit单元测试: 测试分类: 黑河测试:不需要写代码,给输入值,看程序是否能够输出期望的值 白合测试:需要谢代码.关注程序具体的执行流程 Junit使用:白盒测试 步骤: 定义一个测试类(测试用例) 建议: 测试类名:被测试的类名Text —&gt; CalculatorText 包名:xxx.xxx.xx.text —&gt;cn.itcast.text 定义测试 : 可独立运行 建议: 方法名: text测试方法名 —&gt;textAdd() 返回值:void 参数列表:空参 给方法加注解@text 导入junit依赖环境 判定结果: 红色代表失败 绿色代表成功 一般我们会使用断言操作来处理结果 Assert.assertEquals(你期望的结果,运算的结果) 补充: @Before: 修饰的方法会在测试方法之前会被自动执行 @After: 不管有没有出现错误,最后都执行 ##反射: 框架设计的灵魂 框架: 半成品软件.可以在框架的基础上进行软甲开发,简化代码 概念: 将类的各个组成部分封装为其他对象,这就是反射机制 好处: 可以在程序运行过程中,操作这些对象 可以解耦,提高程序的课扩展性. 获取Class类的三种方式 Class.forName(“全类名”):将字节码文件加载进内存,返回Class文件 多数用于配置文件,将类名定义在配置文件中.读取文件加载类 类名.Class通过类名的属性Class获取 多用于参数的传递 对象.getClass():getClass()方法在Object类名中定义着 多用于对象获取字节码文件 结论: 同一个字节码文件(*.class)在第一次运行程序过程中,只会被加载一次,不论通过哪一种方式获取的Class对象都是同一个 Class对象功能: 获取功能: 获取成员变量 File[] getFiles() —&gt;获取的是public修饰的成员变量 File[] getFiled(String name) —&gt;获取指定名称的是public修饰的成员变量 File[] getDeclaredFileds() File[] getDeclaredFiled(String nane) 获取构造方法 * `Constructor&lt;?&gt;[] getConstructors()` * `Constructor&lt;T&gt; getConstructor(类&lt;?&gt;...parameterTypes)` * `Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;...parameterTypes)` * `Constructor&lt;?&gt;[] getDeclaredConstructors()` 获取成员方法 method[] getMethods() method getMethod(String name,类&lt;?&gt;...parameterTypes) method[] getDeclaredMethods() meth0d getDeclaredMethod(String name,类&lt;?&gt;...parameterTypes) 获取类名 String getName() Filed成员变量 操作: 设置值 void set(Object obj, Object value) 获取值 get(Object obj) 忽略访问权限服的安全检查 setAccessible(true) –&gt;暴力反射 Constructor: 构造方法 创建对象: T newInstance(Object...intargs) 如果使用空参数构造方法穿件对象,操作可以简化: Class对象的newInstance methhod:方法对象 执行方法: *Object invoke(Object obj,Object...args); 获取方法名 String getName() —&gt;获取方法名称 注解: 概念: 说明程序的. 给计算看的 注释: 用文字描述程序. 给程序员看的 定义：注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特 性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等 的前面，用来对这些元素进行说明，注释。 作用分类： ①编写文档：通过代码里标识的元数据生成文档【生成文档doc文档】 ② 代码分析：通过代码里标识的元数据对代码进行分析【使用反射】 ③编译检查：通过代码里标识的元数据让编译器能够实现基本的编译检查【Override】 JDK中预定的一些注解 @Override :检测被改注解标注的方法是否继承父类的 @Deprecated ：将该注解标注的内容已过时 @Suppresswarnings ：压制警告 —&gt; 参数一般传递&quot;all&quot; 自定义注解 格式 元注解 public @interface 注解名称{ 属性列表 } 本质 ：本质是就是一个接口，该接口默认继承Annotation public interface MyAnno extends java.lang.annotation.Annotation {} 属性 ：接口里可以注解的方法 – 成员属性 要求 属性的返回值类型 基本数据类型 String 枚举 注解 以上类型的数组 定义了属性，在使用时要给属性赋值 如果定义属性时,使用default关键字给属性初始化值,则使用注解时,可以不进行属性的赋值 如果只有 一个属性需要赋值,并且属性的名称是value可以直接赋值. 数组赋值时,值用{}包裹,如果数组中只有一个值大括号可以省略 元注解 :描述注解的注解 @Target: 描述注解能够作用的位置 ElementType取值: 可以作用于类上 METHOD可以作用于方法上* `FIELD`可以作用于成员变量上 @Retention: 描述注解被保留的阶段 @Retention(RetentionPolicy.RUNTIME):当前被描述的注解,会保留到Class文件中,被字节码读取到 @Documented: 描述注解是否被抽取到api文档中 @Inherited: 描述注解是否被子类继承 在程序使用(解析)注解 获取注解定义的位置的对象 (Class, Method, Field) 获取指定的注解 getannotation(class) 调用注解中的抽象方法获取配置的属性值 小结： 以后大多数时候会使用注解，而不是自定义注解 注解给谁用？ 编译器 解析程序用 注解不是我们程序的一部分，理解为（标签）]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>框架基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下安装MySQL8.0.16]]></title>
    <url>%2F2019%2F06%2F19%2FLinux%E4%B8%8B%E5%AE%89%E8%A3%85MySQL8.0.16%2F</url>
    <content type="text"><![CDATA[引用Linux安装以及使用 注意安装时有需要配置忽略大小写一定要在第一次启动前配置 MySQL8忽略大小写 查找安装路径123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155[root@root ~]# rpm -qa|grep mysqlmysql-community-client-8.0.16-2.el7.x86_64mysql-community-libs-8.0.16-2.el7.x86_64mysql-community-libs-compat-8.0.16-2.el7.x86_64mysql-community-common-8.0.16-2.el7.x86_64mysql-community-server-8.0.16-2.el7.x86_64[root@root ~]# rpm -ql mysql-community-server-8.0.16-2.el7.x86_64/etc/logrotate.d/mysql/etc/my.cnf/etc/my.cnf.d/usr/bin/ibd2sdi/usr/bin/innochecksum/usr/bin/lz4_decompress/usr/bin/my_print_defaults/usr/bin/myisam_ftdump/usr/bin/myisamchk/usr/bin/myisamlog/usr/bin/myisampack/usr/bin/mysql_secure_installation/usr/bin/mysql_ssl_rsa_setup/usr/bin/mysql_tzinfo_to_sql/usr/bin/mysql_upgrade/usr/bin/mysqld_pre_systemd/usr/bin/mysqldumpslow/usr/bin/perror/usr/bin/zlib_decompress/usr/lib/systemd/system/mysqld.service/usr/lib/systemd/system/mysqld@.service/usr/lib/tmpfiles.d/mysql.conf/usr/lib64/mysql/mecab/usr/lib64/mysql/mecab/dic/usr/lib64/mysql/mecab/dic/ipadic_euc-jp/usr/lib64/mysql/mecab/dic/ipadic_euc-jp/char.bin/usr/lib64/mysql/mecab/dic/ipadic_euc-jp/dicrc/usr/lib64/mysql/mecab/dic/ipadic_euc-jp/left-id.def/usr/lib64/mysql/mecab/dic/ipadic_euc-jp/matrix.bin/usr/lib64/mysql/mecab/dic/ipadic_euc-jp/pos-id.def/usr/lib64/mysql/mecab/dic/ipadic_euc-jp/rewrite.def/usr/lib64/mysql/mecab/dic/ipadic_euc-jp/right-id.def/usr/lib64/mysql/mecab/dic/ipadic_euc-jp/sys.dic/usr/lib64/mysql/mecab/dic/ipadic_euc-jp/unk.dic/usr/lib64/mysql/mecab/dic/ipadic_sjis/usr/lib64/mysql/mecab/dic/ipadic_sjis/char.bin/usr/lib64/mysql/mecab/dic/ipadic_sjis/dicrc/usr/lib64/mysql/mecab/dic/ipadic_sjis/left-id.def/usr/lib64/mysql/mecab/dic/ipadic_sjis/matrix.bin/usr/lib64/mysql/mecab/dic/ipadic_sjis/pos-id.def/usr/lib64/mysql/mecab/dic/ipadic_sjis/rewrite.def/usr/lib64/mysql/mecab/dic/ipadic_sjis/right-id.def/usr/lib64/mysql/mecab/dic/ipadic_sjis/sys.dic/usr/lib64/mysql/mecab/dic/ipadic_sjis/unk.dic/usr/lib64/mysql/mecab/dic/ipadic_utf-8/usr/lib64/mysql/mecab/dic/ipadic_utf-8/char.bin/usr/lib64/mysql/mecab/dic/ipadic_utf-8/dicrc/usr/lib64/mysql/mecab/dic/ipadic_utf-8/left-id.def/usr/lib64/mysql/mecab/dic/ipadic_utf-8/matrix.bin/usr/lib64/mysql/mecab/dic/ipadic_utf-8/pos-id.def/usr/lib64/mysql/mecab/dic/ipadic_utf-8/rewrite.def/usr/lib64/mysql/mecab/dic/ipadic_utf-8/right-id.def/usr/lib64/mysql/mecab/dic/ipadic_utf-8/sys.dic/usr/lib64/mysql/mecab/dic/ipadic_utf-8/unk.dic/usr/lib64/mysql/mecab/etc/usr/lib64/mysql/mecab/etc/mecabrc/usr/lib64/mysql/plugin/usr/lib64/mysql/plugin/adt_null.so/usr/lib64/mysql/plugin/auth_socket.so/usr/lib64/mysql/plugin/authentication_ldap_sasl_client.so/usr/lib64/mysql/plugin/component_audit_api_message_emit.so/usr/lib64/mysql/plugin/component_log_filter_dragnet.so/usr/lib64/mysql/plugin/component_log_sink_json.so/usr/lib64/mysql/plugin/component_log_sink_syseventlog.so/usr/lib64/mysql/plugin/component_validate_password.so/usr/lib64/mysql/plugin/connection_control.so/usr/lib64/mysql/plugin/ddl_rewriter.so/usr/lib64/mysql/plugin/debug/usr/lib64/mysql/plugin/debug/adt_null.so/usr/lib64/mysql/plugin/debug/auth_socket.so/usr/lib64/mysql/plugin/debug/authentication_ldap_sasl_client.so/usr/lib64/mysql/plugin/debug/component_audit_api_message_emit.so/usr/lib64/mysql/plugin/debug/component_log_filter_dragnet.so/usr/lib64/mysql/plugin/debug/component_log_sink_json.so/usr/lib64/mysql/plugin/debug/component_log_sink_syseventlog.so/usr/lib64/mysql/plugin/debug/component_validate_password.so/usr/lib64/mysql/plugin/debug/connection_control.so/usr/lib64/mysql/plugin/debug/ddl_rewriter.so/usr/lib64/mysql/plugin/debug/group_replication.so/usr/lib64/mysql/plugin/debug/ha_example.so/usr/lib64/mysql/plugin/debug/ha_mock.so/usr/lib64/mysql/plugin/debug/innodb_engine.so/usr/lib64/mysql/plugin/debug/keyring_file.so/usr/lib64/mysql/plugin/debug/keyring_udf.so/usr/lib64/mysql/plugin/debug/libmemcached.so/usr/lib64/mysql/plugin/debug/libpluginmecab.so/usr/lib64/mysql/plugin/debug/locking_service.so/usr/lib64/mysql/plugin/debug/mypluglib.so/usr/lib64/mysql/plugin/debug/mysql_no_login.so/usr/lib64/mysql/plugin/debug/rewrite_example.so/usr/lib64/mysql/plugin/debug/rewriter.so/usr/lib64/mysql/plugin/debug/semisync_master.so/usr/lib64/mysql/plugin/debug/semisync_slave.so/usr/lib64/mysql/plugin/debug/validate_password.so/usr/lib64/mysql/plugin/debug/version_token.so/usr/lib64/mysql/plugin/group_replication.so/usr/lib64/mysql/plugin/ha_example.so/usr/lib64/mysql/plugin/ha_mock.so/usr/lib64/mysql/plugin/innodb_engine.so/usr/lib64/mysql/plugin/keyring_file.so/usr/lib64/mysql/plugin/keyring_udf.so/usr/lib64/mysql/plugin/libmemcached.so/usr/lib64/mysql/plugin/libpluginmecab.so/usr/lib64/mysql/plugin/locking_service.so/usr/lib64/mysql/plugin/mypluglib.so/usr/lib64/mysql/plugin/mysql_no_login.so/usr/lib64/mysql/plugin/rewrite_example.so/usr/lib64/mysql/plugin/rewriter.so/usr/lib64/mysql/plugin/semisync_master.so/usr/lib64/mysql/plugin/semisync_slave.so/usr/lib64/mysql/plugin/validate_password.so/usr/lib64/mysql/plugin/version_token.so/usr/sbin/mysqld/usr/sbin/mysqld-debug/usr/share/doc/mysql-community-server-8.0.16/usr/share/doc/mysql-community-server-8.0.16/INFO_BIN/usr/share/doc/mysql-community-server-8.0.16/INFO_SRC/usr/share/doc/mysql-community-server-8.0.16/LICENSE/usr/share/doc/mysql-community-server-8.0.16/README/usr/share/man/man1/ibd2sdi.1.gz/usr/share/man/man1/innochecksum.1.gz/usr/share/man/man1/lz4_decompress.1.gz/usr/share/man/man1/my_print_defaults.1.gz/usr/share/man/man1/myisam_ftdump.1.gz/usr/share/man/man1/myisamchk.1.gz/usr/share/man/man1/myisamlog.1.gz/usr/share/man/man1/myisampack.1.gz/usr/share/man/man1/mysql.server.1.gz/usr/share/man/man1/mysql_secure_installation.1.gz/usr/share/man/man1/mysql_ssl_rsa_setup.1.gz/usr/share/man/man1/mysql_tzinfo_to_sql.1.gz/usr/share/man/man1/mysql_upgrade.1.gz/usr/share/man/man1/mysqldumpslow.1.gz/usr/share/man/man1/mysqlman.1.gz/usr/share/man/man1/perror.1.gz/usr/share/man/man1/zlib_decompress.1.gz/usr/share/man/man8/mysqld.8.gz/usr/share/mysql-8.0/dictionary.txt/usr/share/mysql-8.0/innodb_memcached_config.sql/usr/share/mysql-8.0/install_rewriter.sql/usr/share/mysql-8.0/mysql-log-rotate/usr/share/mysql-8.0/uninstall_rewriter.sql/var/lib/mysql/var/lib/mysql-files/var/lib/mysql-keyring/var/run/mysqld[root@root ~]# 查看端口是否开放查看端口是否开放1firewall-cmd --query-port=3306/tcp --zone=public 返回no即未开启，显示yes为已开启。12[root@voda ~]# firewall-cmd --query-port=3306/tcp --zone=public yes 开启端口1firewall-cmd --zone=public --add-port=3306/tcp --permanent 重新加载1firewall-cmd --reload 查看已经打开的端口1firewall-cmd --zone=public --list-ports 1234[root@voda ~]# firewall-cmd --query-port=3306/tcp --zone=publicFirewallD is not running#说明防火墙没有开启 防火墙操作命令12345systemctl status firewalld #查看firewalld状态systemctl stop firewalld #停止firewalldsystemctl start firewalld #开启firewalldsystemctl enable firewalld #开机自启动systemctl disable firewalld #禁止自启动]]></content>
      <categories>
        <category>CentOS7</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux笔记]]></title>
    <url>%2F2019%2F06%2F19%2FLinux%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[批量安装rpm包1rpm -ivh mysql-* 查询进程 1ps -ef |grep tomcat]]></content>
      <categories>
        <category>CentOS7</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL安装后配置]]></title>
    <url>%2F2019%2F06%2F19%2FMySQL%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[首先查看是否只允许本地连接 1cat /var/log/mysqld.log | grep password 1mysql -u root -p 1select user,host from user; localhost代表只允许本地连接不允许其他地址链接我们要修改成% 切换mysql数据库 1use mysql; 如果是刚刚装的数据没有修改过密码就要更改密码之后在操作 1ALTER USER USER() IDENTIFIED BY 'VodeDB@110'; 修改host值()此处不修改除本机其他地址链接时会出现10038,%代表其他地址 123update user set host = '%' where user = 'root';--刷新flush privileges; ###查看host值 1select user,host from user; 更改加密方式(可不做此操作)这里上面host是%我们就用&#39;root&#39;@&#39;%&#39;,是localhost我们就用&#39;root&#39;@&#39;localhost&#39; 1alter user 'root'@'%' identified by 'VodeDB@110' password expire never; 密码一定要符合规则否则出现ERROR 1819 (HY000): Your password does not satisfy the current policy requirements 更新密码更改过host值之后必须更新密码,如果不更新会有1251错误出现 1alter user 'root'@'%' identified with mysql_native_password by 'VodeDB@110'; 12--刷新flush privileges;]]></content>
      <categories>
        <category>CentOS7</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
</search>
